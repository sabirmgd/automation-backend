import { JobAnalysisOutput } from '../schemas/job-analysis.schema';

export function formatJobAnalysisComment(
  analysis: JobAnalysisOutput,
  jobName: string,
  jobUrl?: string
): string {
  const confidenceEmoji = {
    high: 'ğŸŸ¢',
    medium: 'ğŸŸ¡',
    low: 'ğŸ”´',
  };

  const failureTypeEmoji = {
    syntax_error: 'ğŸ“',
    configuration_error: 'âš™ï¸',
    dependency_issue: 'ğŸ“¦',
    resource_constraint: 'ğŸ’¾',
    permission_issue: 'ğŸ”’',
    network_issue: 'ğŸŒ',
    test_failure: 'ğŸ§ª',
    build_error: 'ğŸ”¨',
    environment_issue: 'ğŸŒ',
    external_service: 'ğŸ”Œ',
    unknown: 'â“',
  };

  const emoji = failureTypeEmoji[analysis.failureType] || 'â“';
  const confidence = confidenceEmoji[analysis.confidence] || 'ğŸ”´';

  let comment = `## ${emoji} Job Analysis: ${jobName}\n\n`;

  if (jobUrl) {
    comment += `ğŸ“ [View Job Logs](${jobUrl})\n\n`;
  }

  comment += `### ğŸ” Root Cause\n`;
  comment += `${analysis.rootCause}\n\n`;

  comment += `### ğŸ“Š Analysis Details\n`;
  comment += `- **Failure Type:** ${analysis.failureType.replace(/_/g, ' ')}\n`;
  comment += `- **Affected Component:** ${analysis.affectedComponent}\n`;
  comment += `- **Confidence:** ${confidence} ${analysis.confidence}\n`;

  if (analysis.estimatedFixTime) {
    comment += `- **Estimated Fix Time:** ${analysis.estimatedFixTime}\n`;
  }
  comment += '\n';

  if (analysis.errorDetails && analysis.errorDetails.length > 0) {
    comment += `### ğŸš¨ Error Details\n`;
    analysis.errorDetails.forEach(error => {
      comment += `- ${error}\n`;
    });
    comment += '\n';
  }

  comment += `### ğŸ› ï¸ Suggested Fix\n`;
  if (analysis.suggestedFixSteps && analysis.suggestedFixSteps.length > 0) {
    analysis.suggestedFixSteps.forEach((step, index) => {
      comment += `${index + 1}. ${step}\n`;
      if (
        analysis.suggestedFixCommands &&
        analysis.suggestedFixCommands[index]
      ) {
        comment += `   \`\`\`bash\n   ${analysis.suggestedFixCommands[index]}\n   \`\`\`\n`;
      }
    });
    comment += '\n';
  }

  if (analysis.relatedFiles && analysis.relatedFiles.length > 0) {
    comment += `### ğŸ“ Related Files\n`;
    analysis.relatedFiles.forEach(file => {
      comment += `- \`${file}\`\n`;
    });
    comment += '\n';
  }

  if (analysis.preventionTips && analysis.preventionTips.length > 0) {
    comment += `### ğŸ’¡ Prevention Tips\n`;
    analysis.preventionTips.forEach(tip => {
      comment += `- ${tip}\n`;
    });
    comment += '\n';
  }

  if (analysis.additionalContext) {
    comment += `### â„¹ï¸ Additional Context\n`;
    comment += `${analysis.additionalContext}\n\n`;
  }

  comment += `---\n`;
  comment += `*Generated by CI/CD Analysis Bot* ğŸ¤–\n`;

  return comment;
}

export function formatJobAnalysisSummary(
  analyses: Array<{ jobName: string; analysis: JobAnalysisOutput }>
): string {
  if (analyses.length === 0) {
    return '';
  }

  let summary = `## ğŸ“Š Job Failure Summary\n\n`;
  summary += `Found ${analyses.length} failed job(s):\n\n`;

  analyses.forEach(({ jobName, analysis }) => {
    const emoji = getFailureTypeEmoji(analysis.failureType);
    summary += `### ${emoji} ${jobName}\n`;
    summary += `- **Type:** ${analysis.failureType.replace(/_/g, ' ')}\n`;
    summary += `- **Cause:** ${analysis.rootCause}\n`;
    summary += `- **Quick Fix:** ${
      analysis.suggestedFixSteps[0] || 'Review logs for details'
    }\n\n`;
  });

  return summary;
}

function getFailureTypeEmoji(failureType: string): string {
  const emojiMap: Record<string, string> = {
    syntax_error: 'ğŸ“',
    configuration_error: 'âš™ï¸',
    dependency_issue: 'ğŸ“¦',
    resource_constraint: 'ğŸ’¾',
    permission_issue: 'ğŸ”’',
    network_issue: 'ğŸŒ',
    test_failure: 'ğŸ§ª',
    build_error: 'ğŸ”¨',
    environment_issue: 'ğŸŒ',
    external_service: 'ğŸ”Œ',
    unknown: 'â“',
  };

  return emojiMap[failureType] || 'â“';
}